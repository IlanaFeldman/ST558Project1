---
title: "Vignette"
author: "Ilana Feldman"
date: "10/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Before creating all my functions, I'll keep a code chunk here that keeps track of my libraries and base value.

```{r setup2}
library(httr)
library(jsonlite)
library(tidyverse)
library(purrr)
base <- "https://pokeapi.co/api/v2/"
```

In general, all of my endpoint functions build their URLs in the same way, so, as a good programming practice, it's appropriate to simply have it call a function instead of tracking down and pasting the same spread-out lines of code each time.

```{r URLFunction}
URLtoData <- function(id = NULL, limit = NULL, offset = NULL, endpoint) {
  if (is.null(id) == FALSE) {
    call <- paste0(base, endpoint, id)
    if(!is.null(limit) | !is.null(offset)) {
      warning("Combined ID with limit/offset. Ignoring the latter.")
    }
  } else {
    call <- paste0(base, endpoint, "?limit=", limit, "&offset=", offset)
  }
  Data <- fromJSON(call)
  return(Data)
}
```

I'll be starting off with the encounter methods, although this doesn't have much statistical application, just to make sure that things are working properly. Something that's worth noting is that if you have "encounter-method/?limit=5&offset=3/2", this just ignores the 2 at the end, and if you have "encounter-method/2?limit=5&offset=3", this just ignores everything after the 2, since it has a specific ID. I could take this either way, but I should probably prioritize the ID. I'll also return a warning if you try to put an ID + limit or ID + offset.

I've also added an `alldata` argument, if limit/offset are used, to dig a level deeper and return the individual pieces of information on each of the entries, and a `language` argument to filter by language.

```{r Endpoint1}
EncounterMethod <- function(id = NULL, limit = NULL, offset = NULL, alldata = FALSE, language = NULL) {
Data <- URLtoData(id, limit, offset, endpoint = "encounter-method/")  
  if (!is.null(id)) {
    DataRefined <- Data$names %>% mutate(order = Data$order)
    
    # Checks for language
    if(!is.null(language)) {
      if(toupper(language) %in% c("EN", "ENGLISH")) {
        DataRefined <- DataRefined %>% filter(language$name == "en")
      } else if (toupper(language) %in% c("DE", "GERMAN")) {
        DataRefined <- DataRefined %>% filter(language$name == "de")
      } else {stop("Language not identified in this database.")}
    }
  }
  
  # If there isn't an ID, a limit and offset are used.
  # This is set up so that either or both can be left blank.
  else {
    # If alldata is TRUE, then we need to do a deeper dive, using purrr::map to query everything one level further in, and then sort out the data we want. In this case, that's just the names.
    if (alldata == FALSE) {
      DataRefined <- Data$results
    } else{ 
      AllData <- map(Data$results$url, fromJSON)
      DataRefined <- NULL
      for (i in 1:length(AllData)) {
        DataRefined <- DataRefined %>% bind_rows(AllData[[i]]$names)
      }
    
      # Check for language, as in the case with the ID input.
      if(!is.null(language)) {
        if(toupper(language) %in% c("EN", "ENGLISH")) {
          DataRefined <- DataRefined %>% filter(language$name == "en")
        } else if (toupper(language) %in% c("DE", "GERMAN")) {
          DataRefined <- DataRefined %>% filter(language$name == "de")
        } else {stop("Language not identified in this database.")}
      }
    }
  }
  return(DataRefined)
}
```

The following is a function call that will grab every single encounter method in English and put it into a neat, orderly tibble. I have already run this and stored the data, so in general, I won't be evaluating these since they make a large number of requests to the API.

```{r Endpoint1Data, eval = FALSE}
AllEncounterMethods <- EncounterMethod(limit = 27, alldata = TRUE, language = "English")
```

Next, I'll be making a function that calls various information about berries. This is significantly more complicated than EncounterMethods, since there are a wide variety of helpful values here that are worth looking further into. I'll also want to allow the user to select specific columns without having to guess exactly how they're formatted. 

```{r Endpoint2}
BerryFlavor <- function(id = NULL, limit = NULL, offset = NULL, alldata = FALSE) {
  Data <- URLtoData(id, limit, offset, endpoint = "berry-flavor/")
  if (!is.null(id)) {
    RefinedData <- Data$berries
  }
  
  else {
    if (alldata == FALSE) {
      RefinedData <- Data$results
    }
    else {
      Data <- map(Data$results$url, fromJSON)
      RefinedData <- NULL

      for(i in 1:length(Data)) {
        RefinedData <- RefinedData %>% bind_rows(cbind("flavor" = Data[[i]]$name, Data[[i]]$berries))
      }
    }
  }
  return(RefinedData)
}

```

In case I need it, I'll be pulling information from all 6 endpoints.

```{r Endpoint2Data, eval = FALSE}
AllBerryFlavors <- BerryFlavor(limit = 5, alldata = TRUE)
```

Moving onto some of the more complex endpoints: I wanted to examine the information on berries, which requires me to connect to the Berry endpoint, but there are other endpoints that contain more subtle information on berries as well.

In order to make things a little easier for the user, I've included a function that allows you to pick specific columns, without necessarily getting the exact name of the column right. Specifically, I made it so that spaces and symbols aren't needed, and there are multiple keywords you can type in to get the desired column for many of the columns.

```{r Endpoint3}
BerryFilter <- function(berryoutput, colfilter) {
  # The idea is to run (matrix of possible values) %in% colfilter
  # Then whichever columns have a TRUE value get used in select().
  BerryLegalValues <- matrix(c("id", NA, NA,
                          "firmness", "firm", NA,
                          "flavor", "flavors", NA,
                          "potency", NA, NA,
                          "growthtime", "growth", "time",
                          "item", "items", NA,
                          "maxharvest", "harvest", NA,
                          "name", "names", NA,
                          "naturalgiftpower", "giftpower", "power",
                          "naturalgifttype", "gifttype", "type",
                          "size", "sizes", NA,
                          "smoothness", "smooth", NA,
                          "soildryness", "soil", "dryness"), nrow = 3)
  MatchLegalValues <- matrix(BerryLegalValues %in% tolower(str_replace_all(colfilter,"[^[:alnum:]]",
                             "")), nrow = 3)
  SelectedCols <- numeric()
  for(i in 1:ncol(BerryLegalValues)) {
    if (any(MatchLegalValues[,i])) {
      SelectedCols <- c(SelectedCols, i)
    }
  }
  return(select(berryoutput, all_of(SelectedCols)))
}

# As for the function that will call from this endpoint:
Berry <- function(id = NULL, limit = NULL, offset = NULL, alldata = FALSE, colfilter = NULL) {
  Data <- URLtoData(id, limit, offset, endpoint = "berry/")
  if (!is.null(id)) {
    # I do some mildly funky stuff here to get R to cooperate and get the list returned from fromJSON
    # into an orderly data frame.
    BerryTibble <- read_csv("\n", col_names = names(Data))
    BerryTibble[1:5,] <- NA
    for (i in 1:ncol(BerryTibble)){
      BerryTibble[,i] <- Data[[i]][1]
    }
    CompleteData <- BerryTibble %>% mutate(potency = Data[2]$flavors$potency) %>% relocate(potency,
                                   .before = growth_time) %>% relocate(id, .before = firmness)
    if (is.null(colfilter)) {
      RefinedData <- CompleteData
    } else {
      RefinedData <- BerryFilter(CompleteData, colfilter)
    }
  }
  # If colfilter isn't NULL, CompleteData will be filtered out into RefinedData towards the end.
  
  # Things do get more complicated if we have limit+offset and alldata = TRUE.
  # In that case, I'll just run a for() loop, since this isn't an incredibly time intensive task,
  # to get each individual berry in order.
  else {
    if (alldata == FALSE) {
      RefinedData <- Data$results
    }
    else {
      Data <- map(Data$results$url, fromJSON)
      CompleteData <- NULL

      for(i in 1:length(Data)) {
        TempTibble <- read_csv("\n", col_names = names(Data[[i]]), show_col_types = FALSE)
        TempTibble[1:5,] <- NA
        for (j in 1:ncol(TempTibble)){
          TempTibble[,j] <- Data[[i]][[names(Data[[i]])[j]]][1]
        }
        TempTibble <- TempTibble %>% mutate(potency = Data[[i]]$flavors$potency) %>%
          relocate(potency, .before = growth_time) %>% relocate(id, .before = firmness)
        CompleteData <- CompleteData %>% bind_rows(TempTibble)
      }
      if (is.null(colfilter)) {
        RefinedData <- CompleteData
      } else {
        RefinedData <- BerryFilter(CompleteData, colfilter)
      }
    }
  }
  return(RefinedData)
}
```

With the relevant berry endpoint functions created, I can now pull all of the Berry information and filter it by the columns that I may be interested in for my statistical analysis. Since I'm removing the flavor columns, I can use `dplyr::distinct` to reduce this down from 320 to 64 rows.

```{r Endpoint3Data, eval = FALSE}
AllBerries <- distinct(Berry(limit = 64, alldata = TRUE, colfilter = c("id", "growthtime", "maxharvest", "item", "naturalgiftpower", "naturalgifttype", "size", "smoothness", "soildryness")))
```

The remaining endpoints will be various subsets of items, which I'll use to divide up the berries into various types for statistical analysis. As before, I'll include a function/input that allows you to filter out specific columns when appropriate. All three of these appear to filter berries into different categories in different ways, which may be interesting to examine.

```{r Endpoint4}
ItemCatFilter <- function(itemcatoutput, colfilter) {
  # This function is essentially the same as for filtering Berry, but with different values.
    ItemCatLegalValues <- matrix(c("id", NA, NA,
                          "item", "items", NA,
                          "url", "itemurl", "itemsurl",
                          "name", NA, NA,
                          "names", NA, NA,
                          "pocket", "pockettype", "type"), nrow = 3)
  MatchLegalValues <- matrix(ItemCatLegalValues %in% tolower(str_replace_all(colfilter,"[^[:alnum:]]",
                             "")), nrow = 3)
  SelectedCols <- numeric()
  for(i in 1:ncol(ItemCatLegalValues)) {
    if (any(MatchLegalValues[,i])) {
      SelectedCols <- c(SelectedCols, i)
    }
  }
  return(select(itemcatoutput, all_of(SelectedCols)))
}

ItemCategory <- function(id = NULL, limit = NULL, offset = NULL, alldata = FALSE, colfilter = NULL) {
  Data <- URLtoData(id, limit, offset, endpoint = "item-category/")
  if (!is.null(id)) {
    RefinedData <- cbind("pocket$name" = Data$pocket$name, Data$items)
    }
  
  else {
    if (alldata == FALSE) {
      RefinedData <- Data$results
    }
    else {
      Data <- map(Data$results$url, fromJSON)
      CompleteData <- NULL

      for(i in 1:length(Data)) {
        TempTibble <- read_csv("\n", col_names = names(Data[[i]]), show_col_types = FALSE)
        TempTibble[1:nrow(Data[[i]][[names(Data[[i]])[2]]]),] <- NA
        # This is modified from the Berry function because the number of items in 
        # this category changes, whereas it was constant in Berry.
        
        for (j in 1:ncol(TempTibble)){
          TempTibble[,j] <- Data[[i]][[names(Data[[i]])[j]]][1]
        }
        # This unfortunately leaves out items$url, which can actually be helpful, so I'll add it in.
        TempTibble <- TempTibble %>% add_column(Data[[i]][[names(Data[[i]])[2]]][2], .after = "items")
        CompleteData <- CompleteData %>% bind_rows(TempTibble)
      }
      if (is.null(colfilter)) {
        RefinedData <- CompleteData
      } else {
        RefinedData <- ItemCatFilter(CompleteData, colfilter)
      }
    }
  }
  return(RefinedData)
}
```

I'm assuming that all items in the API can be found in one of the item categories. Since the information from `berry/` comes with item names that match up to the item names in the categories, I can do an inner join to get that information in one table. Then, I can compare various metrics of the berries in the context of whichever category they're in.

```{r Endpoint4Data, eval = FALSE}
AllItemCategories <- ItemCategory(limit = 45, alldata = TRUE, colfilter = c("id", "items", "url", "name", "pocket"))
```

It's worth noting that doing this gets a list of all items, just grouped by category. If we wanted to, we could get a similar list without the category grouping by calling `https://pokeapi.co/api/v2/item/?limit=954`. However, this wouldn't be particularly useful without going a level deeper, which would require making 954 additional calls for a massive amount of data which is mostly uninteresting in the context of the statistical analysis I have planned. 

The remaining endpoints more or less follow a similar line of attack compared to the previous ones.

```{r Endpoint5}
ItemAttrFilter <- function(itemattroutput, colfilter) {
    ItemAttrLegalValues <- matrix(c("desc", "descriptions", "description",
                          "id", NA, NA,
                          "items", "item", NA,
                          "name", NA, NA,
                          "names", NA, NA), nrow = 3)
  MatchLegalValues <- matrix(ItemAttrLegalValues %in% tolower(str_replace_all(colfilter,"[^[:alnum:]]",
                             "")), nrow = 3)
  SelectedCols <- numeric()
  for(i in 1:ncol(ItemAttrLegalValues)) {
    if (any(MatchLegalValues[,i])) {
      SelectedCols <- c(SelectedCols, i)
    }
  }
  return(select(itemattroutput, all_of(SelectedCols)))
}

ItemAttribute <- function(id = NULL, limit = NULL, offset = NULL, alldata = FALSE, colfilter = NULL) {
  Data <- URLtoData(id, limit, offset, endpoint = "item-attribute/")
  if (!is.null(id)) {
    RefinedData <- list(Data$name, Data$items)
  }
  else {
    if(alldata == FALSE) {
      RefinedData <- Data$results
    } else {
      Data <- map(Data$results$url, fromJSON)
      CompleteData <- NULL

      for(i in 1:length(Data)) {
        TempTibble <- read_csv("\n", col_names = names(Data[[i]]), show_col_types = FALSE)
        # Due to a plethora of errors resulting from one of the item lists being empty,
        # I've instructed it to simply skip those, since that information can be found with id = # regardless.
        if(!is.null(nrow(Data[[i]][[names(Data[[i]])[3]]]))) {
          TempTibble[1:max(nrow(Data[[i]][[names(Data[[i]])[3]]]),1),] <- NA

          for (j in 1:ncol(TempTibble)){
            TempTibble[,j] <- Data[[i]][[names(Data[[i]])[j]]][1]
          }
          CompleteData <- CompleteData %>% bind_rows(TempTibble)
        }
      }
      if (is.null(colfilter)) {
        RefinedData <- CompleteData
      } else {
        RefinedData <- ItemAttrFilter(CompleteData, colfilter)
      }      
    }
  }
  return(RefinedData)
}
```

```{r Endpoint5Data, eval = FALSE}
AllItemAttributes <- ItemAttribute(limit = 8, alldata = TRUE)
```

```{r Endpoint6}
ItemFlingFilter <- function(itemflingoutput, colfilter) {
    ItemFlingLegalValues <- matrix(c("effectentries", "effect", "effectentry",
                          "id", NA, NA,
                          "items", "item", NA,
                          "name", "names", NA), nrow = 3)
  MatchLegalValues <- matrix(ItemFlingLegalValues %in% tolower(str_replace_all(colfilter,"[^[:alnum:]]",
                             "")), nrow = 3)
  SelectedCols <- numeric()
  for(i in 1:ncol(ItemFlingLegalValues)) {
    if (any(MatchLegalValues[,i])) {
      SelectedCols <- c(SelectedCols, i)
    }
  }
  return(select(itemflingoutput, all_of(SelectedCols)))
}


ItemFlingEffect <- function(id = NULL, limit = NULL, offset = NULL, alldata = FALSE, colfilter = NULL) {
  Data <- URLtoData(id, limit, offset, endpoint = "item-fling-effect/")
  if (!is.null(id)) {
    RefinedData <- data_frame("effectname" = Data$name, Data$effect_entries[1], "id" = Data$id, Data$items)
  }
  else {
    if(alldata == FALSE) {
      RefinedData <- Data$results
    } else {
      Data <- map(Data$results$url, fromJSON)
      CompleteData <- NULL

      for(i in 1:length(Data)) {
        TempTibble <- read_csv("\n", col_names = names(Data[[i]]), show_col_types = FALSE)
        TempTibble[1:nrow(Data[[i]][[names(Data[[i]])[3]]]),] <- NA

        for (j in 1:ncol(TempTibble)){
          TempTibble[,j] <- Data[[i]][[names(Data[[i]])[j]]][1]
        }
        CompleteData <- CompleteData %>% bind_rows(TempTibble)
      }
      if (is.null(colfilter)) {
        RefinedData <- CompleteData
      } else {
        RefinedData <- ItemFlingFilter(CompleteData, colfilter)
      }
    }
  }
  return(RefinedData)
}
```

```{r Endpoint6Data, eval = FALSE}
AllItemFlingEffects <- ItemFlingEffect(limit = 7, alldata = TRUE)
```





